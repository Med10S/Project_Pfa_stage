%YAML 1.1
---

vars:
  address-groups:
    HOME_NET: "[192.168.15.0/24]"
    EXTERNAL_NET: "!$HOME_NET"
    HTTP_SERVERS: "$HOME_NET"
    SMTP_SERVERS: "$HOME_NET"
    SQL_SERVERS: "$HOME_NET"
    DNS_SERVERS: "$HOME_NET"
    TELNET_SERVERS: "$HOME_NET"
    AIM_SERVERS: "$EXTERNAL_NET"

  port-groups:
    HTTP_PORTS: "80"
    SHELLCODE_PORTS: "!80"
    ORACLE_PORTS: 1521
    SSH_PORTS: 22

runmode: autofp
max-pending-packets: 2048
default-log-dir: /var/log/suricata/

# Configuration AF_PACKET
af-packet:
  - interface: ens38
    threads: auto
    cluster-id: 99
    cluster-type: cluster_flow
    defrag: yes
    use-mmap: yes
    ring-size: 32768
    block-size: 131072
    use-emergency-flush: yes

# OUTPUTS - Configuration FIXÉE pour chronologie prévisible
outputs:
  # EVE JSON logging avec timestamps précis
  - eve-log:
      enabled: yes
      filetype: regular
      filename: eve.json
      types:
        - alert:
            payload: yes
            payload-printable: yes
            packet: yes
            metadata: yes
            tagged-packets: yes
            http-body: yes
        - http:
            extended: yes
        - dns:
            query: yes
            answer: yes
        - tls:
            extended: yes
        - files:
            force-magic: no
        - smtp:
        - ssh
        - flow:
            memcap: 64mb
        - stats:
            totals: yes
            threads: no

  # PCAP LOG - SOLUTION 1: Numérotation séquentielle (%n) - VALIDE
  - pcap-log:
      enabled: yes
      # Formats valides Suricata 3.2: %t (thread), %n (séquentiel), %i (interface) UNIQUEMENT
      filename: time_block.pcap        # %n = numéro séquentiel - ordre prévisible
      limit: 30MB                      # Fichiers plus petits pour rotation plus fréquente
      max-files: 50                    # Moins de fichiers pour éviter la confusion
      compression: none
      mode: normal                     # Mode normal pour éviter les conflits de threads
      use-stream-depth: no

  # PCAP LOG - SOLUTION 2: Thread ID (%t) avec limite stricte
  - pcap-log:
      enabled: no                      # Désactivé pour éviter les conflits
      filename: thread_%t.pcap         # %t = thread ID
      limit: 50MB
      max-files: 10                    # Très limité
      compression: none
      mode: normal

  # Fast log pour alertes rapides
  - fast:
      enabled: yes
      filename: fast.log
      append: yes

# Rules
default-rule-path: /etc/suricata/rules
rule-files:
  - local.rules

# Actions
action-order:
  - pass
  - drop
  - reject
  - alert

# Detection engine optimisé
detect-engine:
  - profile: high
  - custom-values:
      toclient-groups: 3
      toserver-groups: 25
  - sgh-mmp-context: auto
  - inspection-recursion-limit: 3000

# libhtp
libhtp:
   default-config:
     personality: IDS
     request-body-limit: 100kb
     response-body-limit: 100kb
     request-body-minimal-inspect-size: 32kb
     request-body-inspect-window: 4kb
     response-body-minimal-inspect-size: 40kb
     response-body-inspect-window: 16kb
     response-body-decompress-layer-limit: 2
     http-body-inline: auto
     randomize-inspection-sizes: yes

# Threading optimisé - RÉDUIT pour éviter les conflits
threading:
  set-cpu-affinity: no
  cpu-affinity:
    - management-cpu-set:
        cpu: [ 0 ]
    - receive-cpu-set:
        cpu: [ 0 ]
    - worker-cpu-set:
        cpu: [ "1-2" ]    # Moins de threads pour moins de fichiers PCAP
        mode: "balanced"
  detect-thread-ratio: 1.0           # Ratio réduit

# Logging
logging:
  default-log-level: info
  outputs:
  - console:
      enabled: yes
  - file:
      enabled: yes
      level: info
      filename: suricata.log

# Capture settings
capture:
  disable-offloading: true

# Flow settings pour meilleur tracking
flow:
  memcap: 128mb
  hash-size: 65536
  prealloc: 10000
  emergency-recovery: 30

# NOUVEAU: Configuration pour PCAP ring buffer plus prévisible
pcap-file:
  compression: none
  preallocate-file: 1GB    # Pré-allocation pour éviter la fragmentation